---
title: "DroidKaigi 2018 に向けて (その3)"
date: 2018-01-29T08:41:12+09:00
draft: true
categories: [DroidKaigi]
---

本日は 2018/01/29 であり、DroidKaigi 本番 (2018/02/08) までもう二週間もないところまできた。
来週の木曜日である。

gomobile 関連で色々調べて分かったことを書いておく。

## JNI だけで Toast を出すのは無理な気がする

`Toast.makeText(this, "hogehoge", Toast.SHORT_LENGTH);`

「Java でやるなら」、上のような書き方をすれば Toast は出る。実に簡単。

これと同じことを gomobile w/ JNI でやろうと思うと、以下のようなコードになる。
(下記はエラーチェックを省略している)

先に書いておくと、下記のコードは正しく動作しない。

```go
package toast

/*
#include <jni.h>
#include <stdlib.h>

static int
showToast(uintptr_t java_vm, uintptr_t jni_env, uintptr_t jni_ctx, char* text) {
    JNIEnv* env = (JNIEnv*)jni_env;
    jobject ctx = (jobject)jni_ctx;

    // Toast クラスの取得 ... 1
    jclass toast = (*env)->FindClass(env, "android/widget/Toast");

    // makeText メソッドの ID を取得 ... 2
    jmethodID makeText = (*env)->GetStaticMethodID(env, toast, "makeText",
        "(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;");

    // String を生成 ... 3
    jstring jstr = env->NewStringUTF("hogehoge");

    // makeText メソッドを呼び出し ... 4
    jobject toastobj = (*env)->CallStaticObjectMethod(env, toast, makeText,
        ctx, jstr, 0); // 0 = Toast.SHORT_LENGTH

    // show メソッド の IDの を取得 ... 5
    jmethodID methodShow = (*env)->GetMethodID(env, toastobj, "show", "()V");

    // show メソッドを呼び出し ... 6
    (*env)->CallVoidMethod(env, toastobj, methodShow);

    return 0;
}
*/
import "C"

import (
    "fmt"

    "github.com/pankona/gomo-simra/simra/jni"
)

type t struct{}

func NewToaster() Toaster {
    return &t{}
}

func (t *t) Show(text string) error {
    jni.RunOnJVM(
        func(vm, env, ctx uintptr) error {
            ret := C.showToast(C.uintptr_t(vm), C.uintptr_t(env), C.uintptr_t(ctx), C.CString(text))
            if ret != 0 {
                fmt.Printf("error!! ret = %d\n", ret)
            }
            return nil
        })
    return nil
}
```

上記のコードは、「4」のところが正しく動作しないようである。`toastobj` には NULL が返却される。
いまのところ原因はよく分かっていないが、`makeText` の第二引数が `CharSequence` であることと、
そこに `jstring` を渡している、ということで、型があってないというのが原因なのではないかと想像する。

`jstring` は `java/lang/String` と同じものという理解でおり、であれば `CharSequence` として扱っても
良いのではないかという気がしないでもない (`String` は `CharSequence` のサブクラスなので) と思うが、
事実、正しく動作していないところを鑑みるには、やっぱりダメなんじゃないかという気がしている。

Java のレイヤでは書ける以下のような例は、
JNI のレイヤでは、おそらく以下のようなコードを表現することができない。

`CharSequence cs = new String("hogehoge");`

